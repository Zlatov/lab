<!--
  См. так же заметку «Принципы программирования»
  ruby/programming_principles/solid/solid.md.
-->

Шаблоны проектирования
===

Пораждающие паттерны (Creational patterns)
---

* Абстрактная фабрика (Factory)
* Синглтон/Одиночка (Singleton)
* Фабричный метод (Factory method) или Виртуальный конструктор (Virtual Constructor)


### Абстрактная фабрика (Factory)

Задача: создать семейство взаимозависимых объектов (не специфицируя их
конкретных классов).

Зачем: Когда необходимо создавать __дерево__ объектов либо одним образом либо
другим. Ось изменений должна проходить через количество интерфейсов фабрик, но
не через количество объектов в дереве.

Решение: Создать абстрактный класс в котором объявлен интерфейс для создания
конкретных классов.


### Фабричный метод (Factory method) или Виртуальный конструктор (Virtual Constructor)

Задача: Определить интерфейс для создания объекта, но оставить подклассам решать
о том какой класс инстанцировать.


Поведенческие шаблоны (Behavioral)
---

* Итератор (Iterator)
* Интерактор (Interactor), Команда (Command или Operation)

### Итератор (Iterator)

Даёт возможность последовательно обходить элементы составных объектов, не
раскрывая их внутреннего представления.

### Интерактор (Interactor), Команда (Command или Operation)

Интерактор — сервисный объект, который создает абстракцию над небольшой областью
знаний (модель предметной области) и инкапсулирет бизнес-логику приложения.

https://mkdev.me/posts/paru-slov-pro-interaktory-v-rails


Структурные паттерны (Structural patterns)
---

* Адаптер (Adapter)
* Заместитель (Proxy)
* Декоратор (Decorator)
* Мост (Bridge)
* Фасад (Facade)


### Адаптер (Adapter)

Задача: Система поддерживает требуемые данные и поведение, но имеет неподходящий интерфейс.

Решение: Адаптер предусматривает создание класса-оболочки с требуемым интерфейсом.

Класс Adapter приводит интерфейс класса Adaptee в соответствие с интерфейсом
класса Target (который реализуется классом Adapter). Это позволяет объекту
Client использовать объект Adaptee (посредством адаптера Adapter) так, словно
он является экземпляром класса Target.

Таким образом Client обращается к интерфейсу Target, реализованному классом
Adapter, который перенаправляет обращение к Adaptee.


### Заместитель (Proxy)

Зачем: когда надо заменить настоящий объект его суррогатом, причём незаметно для
клиентов настоящего объекта. Это позволит выполнить какие-то добавочные
поведения до или после основного поведения настоящего объекта.

Признаки применения паттерна: Класс заместителя чаще всего делегирует всю
настоящую работу своему реальному объекту. Заместители часто сами следят за
жизненным циклом своего реального объекта.


### Декоратор (Decorator)

Декоратор позволяет добавлять объектам новые поведения на лету, помещая их в
объекты-обёртки.

### Мост (Bridge)

Тысяча отчётов различных типов, необходимо написать методы для вывода отчётов в
различных форматах.

### Фасад (Facade)
