# Фильтры групп

Отличается от классических фильтров тем, что нет способа снять выбор с со
значения - в каждом фильтре одно из значений должно быть выбрано.

Исходя из этого, отключение значений приводящих к пустому пересечению может
завести в тупик классический фильтр. Например, два товара с двумя свойствами:
первый - цвет красный, длинна 1м; второй - цвет зелёный, длина 2м. При "выборе"
одного из товаров второй выбрать невозможно.

Таким образом, отключение значений должно быть только визуальным, или не быть
вообще, при переключение на отключённое значение, второе значение должно
перевыбираться в соответствии с данными.

Бизнес логика описана в методе `window.OfferFilters.change`.

## Математика

«__Начальные данные__»

```js
4: {
  "020000001": {
    "cvet": "красный",
    "dlina": "1.5",
  },
  "020000002": {
    "cvet": "красный",
    "dlina": "2",
  },
},
```

Где `4` — ID Предложения, в которых перечислены товары (артикулы) с их
свойствами (цвет - зелёный) относящимися к фильтрам предложений.

1. При инициализации из начальных данных строится «__хэш соответствий__», для
более быстрого доступа к данным.

```js
4: {
  "cvet": {
    "красный": ["020000001", "020000002"],
  },
  "dlina": {
    "1.5": ["020000001"],
    "2": ["020000002"],
  },
},
```

2. При клике мы должны так же определить состояние выбора остальных фильтров,
получив «__данные выбора__»:

```js
{
  "cvet": "красный",
  "dlina": "1.5"
}
```

3. Находим пересечение объединений. А именно: объединяем артикулы в первый
массив, которые имеют цвет красный, объединяем артикулы во второй массив,
которые имеют длину 1.5, и ищем пересечение этих массивов:
```js
unions = {
  "красный": ["020000001", "020000002"],
  "1.5": ["020000001"],
}
intersection = _.uniq(_.intersection(...Object.values(unions)))
```
Недостатком простоты предыдщего алгоритма является то, что пересечение может
быть пустым, вот простой пример иходных данных:
```js
4: {
  "020000001": {
    "cvet": "красный",
    "dlina": "1.5",
  },
  "020000002": {
    "cvet": "зелёный",
    "dlina": "2",
  },
},
```

4. Если пересечение пусто:
  1. Заново определим «__данные выбора__» основываясь на данных клика
  (Предложение/Фильтр/Значение, например — 4/cvet/красный). Возьмём первый
  артикул из «__хэша соответствий__» по данным клика, затем по этому артикулу мы
  можем найти «правильные» «__данные выбора__» прямо из «__начальных данных__»
```js
// хэш соответствий. По данным клика (4/cvet/красный) берём первый артикул - 020000001
4: {
  "cvet": {
    "красный": ["020000001", "020000002"],
  },
  "dlina": {
    "1.5": ["020000001"],
    "2": ["020000002"],
  },
},
// По артикулу из начальных данных можно определить "правильные" данные выбора.
```

  2. Повторяем нахождение пересечения, в этом случае оно должно быть найдено,
  иначем мы просто допустили ошибку в коде.

