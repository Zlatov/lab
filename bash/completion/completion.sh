#!/usr/bin/env bash
exit 0

# Динамически
complete -F _my_command app

# Разово
complete -W "$(app complete)" app

    _my_command(){ #объявляем функцию, которую будем привязывать к анализу
    
    COMPREPLY=() #пока что мы не знаем, что предложить пользователю, поэтому создадим пустой список.
    cur="${COMP_WORDS[COMP_CWORD]}" #получаем текущий вводимый аргумент
    subcommands_1="work history help" #массив подкоманд первого уровня - см. синтаксическое дерево в начале поста.

    if [[ ${COMP_CWORD} == 1 ]] ; then #если вводится первый аргумент, то попробуем его дополнить
        COMPREPLY=( $(compgen -W "${subcommands_1}" -- ${cur}) ) #some magic
        return 0 #COMPREPLY заполнен, можно выходить
    fi
    }

# Ну и самое главное — подключение нашего скрипта к башу на постоянной основе. Это делается либо (топорно) прописыванием вызова нашего скрипта в .bashrc, либо (стандартно, если у вас есть такой файл: ) через /etc/bash_completion. Во втором случае мы должны положить наш скрипт в /etc/bash_completion.d, все скрипты откуда подцепляются из /etc/bash_completion.
