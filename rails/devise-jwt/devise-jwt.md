```rb
User.generate_jti
```

# Процесс обновления токена с использованием `devise-jwt` в Ruby on Rails

## 1. Введение

Когда используется гем `devise-jwt` для аутентификации, время жизни токенов (JWT) может быть ограничено для обеспечения безопасности. Когда срок действия access-токена истекает, необходимо обновить его с помощью refresh-токена.

## 2. Настройка времени жизни токена

Время жизни токенов обычно настраивается в конфигурации гемов. Например, для `devise-jwt` можно указать срок действия токена в `config/initializers/devise.rb`.

Пример настройки:

```ruby
config.jwt do |jwt|
  jwt.expiration_time = 12.hours.to_i  # Время жизни токена
end
```

Время жизни токенов в `devise-jwt` обычно меньше, чем сессий в `devise`, и это связано с принципом безопасности: чем короче время жизни токена, тем безопаснее система.

### Разделение сессий и токенов

Devise управляет сессиями и может иметь длительный срок действия (`config.timeout_in = 12.hours`), в то время как `devise-jwt` управляет непосредственно временем жизни JWT токенов.

### Использование refresh-токенов

Если вам нужно обновлять токены по истечении срока их действия, вы можете настроить refresh-токены. Для этого в `devise-jwt` необходимо добавить соответствующую конфигурацию:

```ruby
config.jwt do |jwt|
  jwt.refresh_leeway = 30.minutes.to_i  # Время до истечения refresh-токена
  jwt.expiration_time = 1.hour.to_i     # Время жизни основного токена
end
```

Затем на сервере нужно настроить эндпоинт для обновления токенов.

## 3. Обновление токенов "на пальцах"

### Как работает обновление токенов:

1. **Получение access-токена**:
   При входе в систему сервер генерирует и отправляет пользователю два токена:
   - **Access-токен** с коротким сроком действия (например, 1 час).
   - **Refresh-токен** с более длительным сроком действия (например, несколько дней или недель).

2. **Что происходит, когда истекает срок действия access-токена?**
   Если срок действия access-токена истекает, фронтенд получает ошибку с кодом 401, например, `Signature has expired`. Это означает, что нужно обновить токен.

3. **Запрос нового access-токена**:
   В случае истечения срока действия токена фронтенд должен автоматически отправить запрос на сервер, используя **refresh-токен**, чтобы получить новый access-токен. Это обычно происходит через отдельный эндпоинт, например:

   - `POST /api/token/refresh`
   
   В запросе фронтенд отправляет refresh-токен, и сервер генерирует новый access-токен.

4. **Ответ от сервера**:
   В ответ на запрос с refresh-токеном сервер возвращает новый access-токен и, возможно, новый refresh-токен.

5. **Использование новых токенов**:
   Фронтенд сохраняет новый access-токен и продолжает использовать его для дальнейших запросов.

### Подходы к обновлению токенов

#### 1. Использование отдельного эндпоинта для refresh-токена

Это стандартный и наиболее распространенный способ. Когда access-токен истекает, фронтенд отправляет запрос на обновление токена.

Пример:

- **Запрос для обновления токена**:

```http
POST /api/token/refresh
Content-Type: application/json
{
  "refresh_token": "refresh_token_value"
}
```

- **Ответ с новым токеном**:

```json
{
  "access_token": "new_access_token_value",
  "refresh_token": "new_refresh_token_value"  // если вы генерируете новый refresh-токен
}
```

Фронтенд сохраняет новый токен и использует его для последующих запросов.

#### 2. Возврат нового токена в заголовках ответа

Можно настроить сервер так, чтобы при истечении срока действия токена, он возвращал новый токен в заголовках ответа. Однако этот подход менее распространен, потому что требует изменения логики на уровне API и усложняет код на фронтенде.

Пример:

- **Ответ с новым токеном в заголовке**:

```http
HTTP/1.1 401 Unauthorized
X-New-Access-Token: new_access_token_value
X-New-Refresh-Token: new_refresh_token_value
```

Фронтенд получает ошибку 401 и обновляет токены в своем хранилище, а затем повторяет запрос.

## 4. Рекомендации

На практике лучший подход — это использование отдельного эндпоинта для обновления токенов с помощью refresh-токенов. Это упрощает архитектуру приложения и позволяет четко разделить логику аутентификации и работу с защищенными ресурсами. Если же вы хотите упростить логику на фронтенде, можно использовать заголовки для возврата новых токенов, но это менее распространенный способ.
