<div id="toc"></div>
<h2 id="on">.on()</h2>
<p>Устанавливает обработчики событий на <a>выбранные элементы</a> страницы. Имеет два варианта использования:</p>
<p><span>.on(events, [selector], [data], handler)<a>:jQuery</a></span><span>v:1.7</span></p>
<p>
  <tt><b>events</b></tt> — тип(ы) обрабатываемых событий. Например "click", "resize" и.т.д. (список всех событий см. ниже). Если необходимо привязать обработчик сразу на несколько типов событий, нужно перечислить их через пробел: "click resize ..."
  <br>
  <tt><b>selector</b></tt> — <a>селектор</a> по которому будут фильтроваться элементы, лежащие внутри уже найденных. В итоге, обработчик будет срабатывать только в том случае, если событие «<a>поднялось</a>» от одного из отфильтрованных элементов.
  <br>
  <tt><b>data</b></tt> — данные, передаваемые обработчику событий. В обработчике будут доступны в переменной
  <tt><a>event.data</a></tt>.
  <br>
  <tt><b>handler</b></tt> — функция, которая будет установлена в качестве обработчика. Вместо функции, можно указать значение
  <tt>false</tt>, это будет эквивалентно установке такой функции:
  <tt>function(){return false;}</tt>.
</p>

<div><span>.on(events-map, [selector], [data])<a>:jQuery</a></span><span>v:1.7</span></div>
<div>
    <p>с помощью этого метода можно установить на выбранные элементы сразу несколько разных обработчиков событий, каждый из которых будет реагировать на свой тип события.</p>
</div>
<div>
    <p>
        <tt><b>events-map</b></tt> — объект, в котором нужно перечислить типы обрабатываемых событий и соответствующие им обработчики. Задается в формате
        <tt>{events-1:handler-1, events-2:handler-2, ...}</tt>, где events-i и handler-i соответствуют параметрам <i>events</i> и <i>handler</i> в первом варианте метода (описанном выше).
        <br>
        <tt><b>selector</b></tt> — см. выше.
        <br>
        <tt><b>data</b></tt> — см. выше..
        <br>
    </p>
</div>

<p>Простой пример:</p>
<p>Метод
    <tt>on()</tt> введен в jQuery-1.7, чтобы объединить три метода библиотеки, устанавливающие обработчики событий на элементы страницы:
    <tt><a>.bind()</a>, <a>.delegate()</a>, <a>.live()</a></tt>. Сами эти методы считаются теперь устаревшими, хотя еще поддерживаться. Установить обработчик, срабатывающий только один раз, по прежнему можно только с помощью отдельного метода
    <tt><a>.one()</a></tt>.</p>
<div>
    <p>Убрать установленный обработчик можно с помощью метода <a>off()</a>.</p>
</div>
<table>
    <tbody>
        <tr>
            <td>
                <div>
                    <h2>Содержание</h2> <span>[<a>убрать</a>]</span></div>
                <ul>
                    <li><a><span>1</span> <span>Типы обрабатываемых событий (параметр events)</span></a>
                        <ul>
                            <li><a><span>1.1</span> <span>Пространство имен</span></a></li>
                        </ul>
                    </li>
                    <li><a><span>2</span> <span>Прямая и делегированная обработка (параметр selector)</span></a></li>
                    <li><a><span>3</span> <span>Обработчики событий (параметр handler)</span></a></li>
                    <li><a><span>4</span> <span>Передача дополнительных данных в обработчик (параметр data)</span></a></li>
                    <li><a><span>5</span> <span>Дополнительные замечания</span></a></li>
                    <li><a><span>6</span> <span>Примеры</span></a></li>
                    <li><a><span>7</span> <span>Ссылки</span></a></li>
                </ul>
            </td>
        </tr>
    </tbody>
</table>
<script>
if (window.showTocToggle) { var tocShowText = "показать"; var tocHideText = "убрать";
    showTocToggle(); }
</script>
<h2> <span>Типы обрабатываемых событий (параметр events)</span></h2>
<p>В качестве первого параметра метода (тип события) может быть использовано любое строковое значение. Если необходимо обрабатывать одно из стандартных javascript-событий, то следует использовать следующие значения:
    <tt>blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error</tt>. Каждый из этих типов имеет одноименный метод, являющейся краткой формой метода
    <tt>on()</tt> . К примеру, использование
    <tt>click(handler)</tt> равнозначно
    <tt>on("click", handler)</tt>.</p>
<p>
    <br> Если тип события не совпадет ни с одним из значений представленных выше, то будет воспринято jQuery как пользовательское событие. Такие события организуют сами пользователи (в смысле, пользователи библиотеки — программисты), генерируя их (события) с помощью методов
    <tt><a>trigger()</a></tt> и
    <tt><a>triggerHandler()</a></tt>.</p>
<h3> <span>Пространство имен</span></h3>
<p>Тип событий может быть задан с указанием пространства имен, например:
    <tt>on('click.name', handler)</tt>. Здесь
    <tt>name</tt> является пространством имен, а
    <tt>click</tt> — типом события. Пространство имен позволяет разделить обработчики одних и тех же событий на подгруппы, которые, в последствии, будет легко отдельно вызывать (методом
    <tt><a>trigger()</a></tt>) и удалять (методом
    <tt><a>off()</a></tt>).</p>
<p>Можно указывать сразу несколько пространств имен:
    <tt>on('click.name1.name2', handler)</tt>. Чтобы обратиться к такому событию, достаточно указать любое из них (или не указывать вовсе). Таким образом, пространства имен похожи по своей сути на классы в css.</p>
<h2> <span>Прямая и делегированная обработка (параметр selector)</span></h2>
<p>Если этот параметр не задан или равен
    <tt>null</tt>, то обработчик события будет установлен на <a>выбранные элементы</a> и срабатывать, в случаях, когда событие возникло непосредственно на этих элементах или «<a>поднялось</a>» от их потомков. Это самая обычная обработка событий и ее называют <i><b>непосредственной</b></i> или <i><b>прямой</b></i>.</p>
<p>
    <br> Однако, прямая обработка событий имеет свои недостатки. Допустим на странице есть список (
    <tt>ul</tt>), на элементах которого необходимо обрабатывать событие click. Если после установки соответствующих обработчиков, в список будут добавлены новые элементы, то они уже не будут реагировать на «клики», поскольку непосредственно к новым элементам, обработчики прикреплены не были. Эта особенность может породить много проблем и коварных логических ошибок.</p>
<p>
    <br> Для таких случаев jQuery имеет возможность организовывать так называемую <i><b>делегированную</b></i> обработку событий. В этом случае, jQuery вместо заданного обработчика (в параметре <i>handler</i>) устанавливает собственный специальный обработчик. Причем он не устанавливается непосредственно на элементы, на которых необходимо обрабатывать события (назовем их inner-элементами), а на содержащие их элементы (назовем их outer-элементами. Получается, что inner находятся внутри outer). После того, как событие происходит на одном из элементов inner, оно начинает <a>подниматься вверх по иерархии DOM</a>. В какой то момент оно оказывается на одном из элементов outer, на котором срабатывает специально установленный обработчик, который проверяет, поднялось ли событие от одного из элементов inner. Если это так — запускается обработчик <i>handler</i>.</p>
<p>В случае делегированной обработки, добавление новых inner-элементов внутрь outer-элементов, не нарушает работоспособность скрипта — события исправно обрабатываются, даже если они возникли на новых inner элементах.</p>
<p>Чтобы организовать делегированную обработку, необходимо во втором параметре метода
    <tt>on</tt> задать <a>селектор</a>. В этом случае роль outer-элементов будут играть элементы к которым был применен метод, а роль элементов inner — элементы, находящиеся внутри outer и удовлетворяющие заданному селектору. То есть, если необходимо делегировано обрабатывать событие click на элементах списка, то следует делать это так:</p>
<dl>
    <dd>
        <tt>$('ul').on('click', 'li', function(){ // обработчик ...</tt>.</dd>
</dl>
<p>Прямые обработчики в этой же ситуации устанавливались бы так:</p>
<dl>
    <dd>
        <tt>$('ul li').on('click', function(){ // обработчик ...</tt>.</dd>
</dl>
<p>
    <br> Второе важное преимущество делегированной обработки это экономия вычислительных ресурсов. Допустим, есть список, содержащий несколько сотен или даже тысяч элементов. А нам нужно обрабатывать нажатие мышью по ним. Тогда, чтобы обрабатывать события напрямую, нужно будет привязать обработчик ко всем элементам, что потребует значительных вычислительных ресурсов. При делегированной обработке, будет установлен только один обработчик, который будет «ловить» события от всех элементов списка.</p>
<p>Небольшой пример. Так можно организовать делегированную обработку нажатия по элементам списка:</p>
<div><a>Скрыть исходный код</a> &nbsp; <a>Применить изменения</a></div><span>Результат:</span>
<p>Делегированная обработка событий имеет и обратную сторону медали — чем ближе будет прикреплен ловящий события обработчик (outer-элемент) к вершине дерева DOM, тем чаще он будет вызываться, поскольку он будет ловить события всплывшие от большего количества элементов. При каждом таком вызове он будет производить проверку, не является ли источник этого события нужным элементом. Таким образом, чем выше в иерархии документа будет установлен делегированный обработчик, тем больше это будет вызывать вычислительных затрат. Поэтому, стоит привязывать делегированные обработчики как можно ближе к интересующим элементам.</p>
<p>
    <br> По спецификации W3C, события
    <tt>focus</tt> и
    <tt>blur</tt> не имеют особенности <a>подниматься вверх по иерархии DOM</a>, однако в jQuery организованы их альтернативы —
    <tt>focusin</tt> и
    <tt>focusout</tt>, которые умеют «всплывать». Поэтому, если вы попытаетесь установить делегированные обработчики
    <tt>focus</tt> или
    <tt>blur</tt>, то jQuery по факту будет отслеживать
    <tt>focusin</tt> и
    <tt>focusout</tt>. Чтобы избежать возможных недоразумений, делегированную обработку приобретения и потери фокуса лучше осуществлять обработкой
    <tt>focusin</tt> и
    <tt>focusout</tt>.</p>
<p>
    <br> Во всех браузерах, событие
    <tt>load</tt>, не всплывает вверх по иерархии. В IE 8 и младше, события
    <tt>paste</tt> и
    <tt>reset</tt> так же не обладают этим свойством. В связи с этим, не следует обрабатывать эти события делегированно. Привязывать обработчики этих событий следует непосредственно на элементы, на которых они происходят (без делегирования).</p>
<h2> <span>Обработчики событий (параметр handler)</span></h2>
<p>В качестве параметра <i>handler</i> должна быть указана функция (или значение
    <tt>false</tt>, но об этом позже). Это может быть анонимная функция:</p>
<p>или именем заданной функции:</p>
<p>Когда происходит событие, jQuery передает в вызываемый обработчик <a>объект event</a>, в котором содержится вся вспомогательная информация по происходящему событию. Этот объект немного отличается от стандартных объектов событий, которые предоставляют браузеры (их получают обработчики, установленные обычными средствами javascript). Библиотека jQuery, изменяет некоторые поля для обеспечения кроссбраузерности. Так или иначе, всегда можно добраться и до нативного объекта события (тот, который предоставляет браузер), он лежит в поле
    <tt>event.originalEvent</tt>.</p>
<p>
    <br> После возникновения, событие всегда <a>всплывает по иерархии DOM</a> вплоть до объекта
    <tt>document</tt>. Если при обработке события необходимо остановить всплытие, нужно вызвать метод
    <tt>event.stopPropagation()</tt> внутри обработчика. В результате, данное событие прекратит далнейшее всплытие по дереву DOM. Однако, если на текущем элементе были установлены другие невыполненные обработчики, они будут выполнены. Чтобы этого избежать нужно вместо
    <tt>stopPropagation()</tt> вызвать
    <tt>event.stopImmediatePropagation()</tt>.</p>
<p>Многие события порождают выполнение связанных с ними действий. Например, сразу после того, как на ссылке происходит событие клик, происходит переход на другую страницу. Чтобы отменить выполнение этих действий, можно внутри обработчика события вызвать
    <tt>event.preventDefault()</tt>. Конечно, не все события порождают дополнительные действия, а так же, не все действия могут быть предотвращены (см. <a>W3C спецификацию</a>).</p>
<p>Если вместо функции в параметре <i>handler</i> задать
    <tt>false</tt>, то event.stopPropagation() и event.preventDefault() будут вызваны автоматически. Вообще, задание
    <tt>false</tt> идентично установке такого обработчика:</p>
<dl>
    <dd>
        <tt>function(){ return false; }</tt>
    </dd>
</dl>
<p>То есть, например после кода:</p>
<dl>
    <dd>
        <tt>$("a.disabled").on("click", false);</tt>
    </dd>
</dl>
<p>нажатие по ссылкам с классом disabled не будет приводить к переходу на другие страницы, а так же, событие не будет передаваться родительским элементам.</p>
<p>
    <br> Переменная
    <tt>this</tt> внутри обработчика всегда содержит DOM-элемент, на котором отлавливается событие. При прямой обработке события это будет один из выбранных элементов, а при делегированной — элемент, лежащий внутри одного из выбранных элементов и удовлетворяющий параметру <i>selector</i>. Создать <a>объект jQuery</a> по
    <tt>this</tt> элементу можно так
    <tt>$(this)</tt>.</p>
<h2> <span>Передача дополнительных данных в обработчик (параметр data)</span></h2>
<p>Если параметр <i>data</i> задан, то он будет доступен в обработчике в
    <tt>even.data</tt>. В этот параметр можно передавать данные любого типа, однако, нужно быть осторожным при передаче строк — если при этом параметр <i>selector</i> не будет задан, то библиотека воспримет заданную строку в качестве этого параметра. Чтобы этого избежать нужно задать в параметре <i>selector</i>
    <tt>null</tt>. Удобнее всего задавать параметр <i>data</i> с помощью объектов. В этом случае, в обработчик можно передать сразу много данных.</p>
<p>Начиная с jQuery-1.4 один и тот же обработчик может быть привязан к одному элементу более одного раза. Поскольку вызов абсолютно идентичных действий более одного раза, вряд-ли, может быть полезным, эта особенность имеет ценность при различных заданных параметрах дата:</p>
<p>Помимо параметра <i>data</i> есть и другой способ передать параметры в обработчик — при ручном вызове событий с помощью методов
    <tt><a>.trigger()</a></tt> или
    <tt><a>.triggerHandler()</a></tt>, можно передавать дополнительные данные в их параметрах.</p>
<h2> <span>Дополнительные замечания</span></h2>
<p>Большинство событий, как например нажатие мышью по элементу (
    <tt>click</tt>) происходят относительно редко и проблем с их обработкой практически не возникает. Однако такие события как
    <tt>mousemove</tt> и
    <tt>scroll</tt> могут происходить несколько раз в секунду. В этом случае, частое выполнение обработчиков может потребовать значительных вычислительных ресурсов компьютера и приводить к зависанию. Избежать этого можно, если грамотно организовать выполнение обработчиков. Например, стоит кэшировать вычисляемые величины, вместо того, чтобы считать их каждый раз заново. И в первую очередь следует кэшировать <a>объекты jQuery</a>, поскольку их создание зачастую требует весомых вычислительных затрат. Например, рассмотрим случай, когда нужно в элементе с идентификатором elm прописывать координаты мыши, когда она движется над элементом с классом mousemove-elm:</p>
<p>Если обработчики часто выполняемых событий не удается оптимизировать в достаточной степени, то следует сократить количество их вызовов, используя
    <tt>setTimeout</tt>:</p>
<p>
    <br> Чтобы привязывать события к элементам страницы, jQuery требуется возможность устанавливать на них данные, в качестве свойств. Элементы
    <tt>object</tt>,
    <tt>embed</tt> и
    <tt>applet</tt> не имеют таких особенностей, поэтому установленные на них обработчики работать не будут.</p>
<p>
    <br> Событие
    <tt>error</tt> объекта window, обладает нестандартными входными параметрами и возвращаемым значением, поэтому jQuery не поддерживает его обработку. Установить обработчик на это событие можно только стандартным методом — присвоив функцию величине
    <tt>window.onerror</tt>.</p>
<h2> <span>Примеры</span></h2>
<p>Выведем на экран сообщение с текстом параграфа, по которому был совершен клик мышью:</p>
<div></div>
<p>
    <br> Передадим данные в обработчик, который задан отдельной функцией:</p>
<p>
    <br> Предотвратим отправку данных формы, а так же дальнейшее всплытие события, если переменная flag не равна true:</p>
<p>Предотвратим только отправку данных формы, если переменная flag не равна true. Таким образом несмотря на то, что данные не будут отправлены, а страница перезагружена, событие submit продолжит свой путь к вершине иерархии DOM - объекту document:</p>
<p>В примере показано, как можно осуществить обработку событий наведения, нажатия и двойного нажатия на элемент:</p>
